### JavaScript——模块化

#### 什么是模块？
就好比写书的作者一样，会把一本书分成一个个的章节，再把每一章的内容分成若干节，然后构建成一本完整的书，让书更加有条理性和可阅读性。而作为一个程序员，就可以把代码分成一些模块，然后组成一个完整的“功能”

#### 模块化的好处——降低代码耦合性
+ 可维护性：模块的独立性，一个良好的模块会减少外面的代码对自己依赖，可以独立的去更新和改进
+ 命名空间：莫葵花开发封装变量，可以避免污染全局环境
+ 可复用性：将自己的模块引入到不同项目，避免复制粘贴

#### 模块化的实现
1. ES6之前
在ES6之前，JavaScript不支持类的概念，而刚好创建一个函数的时候，解析器会针对函数产生一个新的运行环境，函数运行完了之后就会销毁一切。从而就可以随意创建对象，达到了类似私有变量的效果，避免了父命名空间的冲突

##### 匿名函数
```js
(function(){
    //在函数的作用域中下面的变量是私有的
    var myGrades = [93,95,88,0,55,97];

    var average = function(){
        var total = myGrades.reduce(function(accumulator,item){
            return accumulator+item;
        },0)
        return 'Your average grade is ' + total / myGrades.length + '.';
    }

    var failing = function(){
        var failingGrades = myGrades.filter(function(item){
            return item < 70;
        })
        return "you failed" + failingGrades.length + 'times.';
    }
    console.log(failing()); //You failed 2 times.

}());
```
+ 注：要用圆括号把整个函数包起来，如果语句直接以关键词开始，会被认为是一个函数声明，而不是函数语句。函数声明必须有名字，函数语句才可以匿名

##### 把全局函数注入到匿名函数
```js
(function (globalVariable) {

  // 在函数的作用域中下面的变量是私有的
  var privateFunction = function() {
    console.log('Shhhh, this is private!');
  }

  // 通过全局变量设置下列方法的外部访问接口
  // 与此同时这些方法又都在函数内部

  globalVariable.each = function(collection, iterator) {
    if (Array.isArray(collection)) {
      for (var i = 0; i < collection.length; i++) {
        iterator(collection[i], i, collection);
      }
    } else {
      for (var key in collection) {
        iterator(collection[key], key, collection);
      }
    }
  };

  globalVariable.filter = function(collection, test) {
    var filtered = [];
    globalVariable.each(collection, function(item) {
      if (test(item)) {
        filtered.push(item);
      }
    });
    return filtered;
  };

  globalVariable.map = function(collection, iterator) {
    var mapped = [];
    globalUtils.each(collection, function(value, key, collection) {
      mapped.push(iterator(value));
    });
    return mapped;
  };

 }(globalVariable));
```
+ 在上例中，```globalVariable```是唯一一个全局变量，这种做法比完全匿名的闭包的好处是，代码结构更清晰，而且性能更好。我们能够看到函数内部传递进来了全局变量，所以依赖关系非常清晰。其次在函数内部调用 ```globalVarible``` 的时候，解释器能够直接找到局部的 ```globalVarible```，就不用上溯到外部的 ```globalVarible```.

##### 对象接口
```js
var myGradesCalculate = (function(){

    var myGrades = [93,95,88,0,55,97];
    // 通过接口在外部访问下列方法
    // 与此同时这些方法又都在函数内部
    return {
        average: function(){
            var total = myGrades.reduce(function(accumulator,item){
                return accumulator+item;
            },0);

            return 'Your average grade is ' + total / myGrades.length + '.';
        },
        failing: function() {
            var failingGrades = myGrades.filter(function(item) {
                return item < 70;
            });

            return 'You failed ' + failingGrades.length + ' times.';
        }
    }
})();

myGradesCalculate.failing(); // 'You failed 2 times.' 
myGradesCalculate.average(); // 'Your average grade is 71.33333333333333.'
```

+ 立即执行的匿名函数返回了一个对象。这样就算使用独立的对象接口

##### 把要公开的属性专门放在一个对象声明中返回
```js
var myGradesCalculate = (function () {
    
  var myGrades = [93, 95, 88, 0, 55, 91];
  
  var average = function() {
    var total = myGrades.reduce(function(accumulator, item) {
      return accumulator + item;
      }, 0);
      
    return'Your average grade is ' + total / myGrades.length + '.';
  };

  var failing = function() {
    var failingGrades = myGrades.filter(function(item) {
        return item < 70;
      });

    return 'You failed ' + failingGrades.length + ' times.';
  };
  // 将公有指针指向私有方法

  return {
    average: average,
    failing: failing
  }
})();

myGradesCalculate.failing(); // 'You failed 2 times.' 
myGradesCalculate.average(); // 'Your average grade is 71.33333333333333.'
```

+ 相比于前一种方法，这种是默认所有的变量和方法都是私有的，只在最后显示return对象的时候，才选择暴露出对外接口，接口比较清晰

##### CommonJS和AMD
上面这些方法都有一个共同点：**使用一个特定的全局模块名来把一些私有变量和方法包起来，然后通过闭包来创建一个私有的命名空间。**

缺点：无法管理不同模块之间的依赖关系。因为js是顺序执行的